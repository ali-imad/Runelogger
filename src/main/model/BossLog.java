package model;

import model.logging.Event;
import model.logging.EventLog;
import model.persistence.Writable;
import org.json.JSONArray;
import org.json.JSONObject;

import java.util.ArrayList;

/*
    The master BossLog that handles entry addition and removal, initializing and handling various Boss
    objects to store the KillEntry's in.
 */
public class BossLog implements Writable {
    private final ArrayList<Boss> bosses;  // bosses we are logging kills of
    private final ArrayList<KillEntry> kills;  // store all the entries generated by BossLog

    // EFFECTS: initialize the application with Vorkath, Giant Mole, and Zulrah available for logging
    public BossLog() {
        this.bosses = new ArrayList<>();
        this.kills = new ArrayList<>();
        // set up initial bosses to select from
        this.addNewBoss("Vorkath");
        bosses.get(0).setImagePath("data/res/img/vorkathsquare.png");
        this.addNewBoss("Giant Mole");
        bosses.get(1).setImagePath("data/res/img/giantmolesquare.png");
        this.addNewBoss("Zulrah");
        bosses.get(2).setImagePath("data/res/img/zulrahsquare.png");
    }

    public KillEntry[] getKills() {
        return kills.toArray(new KillEntry[0]);
    }

    // REQUIRES: this.kills.size() < i
    // MODIFIES: this.bosses.get(i), this.kills
    // EFFECTS: Generate and add a new entry to the BossLog, updating the appropriate boss by index in this.bosses
    public void addNewEntry(int bossIdx, int time, int value) {
        Boss boss = this.bosses.get(bossIdx);
        KillEntry newEntry = new KillEntry(boss, time, value);
        boss.add(newEntry);
        this.kills.add(newEntry);
        EventLog.getInstance().logEvent(new Event("Boss " + boss.getName() + " had a kill logged with value "
                + value + " and time " + time));
    }

    // REQUIRES: this.boss.contains(bossName)
    // MODIFIES: this.bosses, this.kills
    // EFFECTS: Generate and add a new entry to the BossLog, updating the appropriate boss by name.
    //          If the boss doesn't exist, make it and add the entry!
    public void addNewEntryByName(String bossName, int time, int value) {
        Boss toFind = new Boss(bossName);
        for (Boss boss : this.bosses) {
            if (boss.equals(toFind)) {
                KillEntry newEntry = new KillEntry(boss, time, value);
                boss.add(newEntry);
                this.kills.add(newEntry);
                EventLog.getInstance().logEvent(new Event("Boss " + boss.getName()
                        + " had a kill logged with value "
                        + value + " and time " + time));
                return;
            }
        }

        // we could not find the boss in the list, so make a new boss and add it to the logger
        addNewBoss(bossName);

        int newBossIdx = this.bosses.size() - 1;
        addNewEntry(newBossIdx, time, value);
        EventLog.getInstance().logEvent(new Event("Boss " + bossName
                + " had a kill logged with value "
                + value + " and time " + time));

    }

    // EFFECTS: Returns a readonly array of the bosses to reference
    public Boss[] getBosses() {
        return this.bosses.toArray(new Boss[0]);
    }

    // EFFECTS: Returns a boss from a name if it exists
    public Boss getBoss(String name) {
        for (Boss b : this.bosses) {
            if (b.equals(new Boss(name))) {
                return b;
            }
        }
        addNewBoss(name);
        return getBoss(name);
    }

    // REQUIRES: this.kills.size() < x
    // EFFECTS: Get an entry at a specific index
    public KillEntry getEntry(int x) {
        return this.kills.get(x);
    }

    // REQUIRES: this.kills.size() < i
    // MODIFIES: this.boss.get(i), this.kills
    // EFFECTS: Remove an entry from the BossLog
    public void removeEntry(int i) {
        KillEntry entry = getEntry(i);
        entry.getBoss().removeEntry(entry);
        this.kills.remove(entry);
        EventLog.getInstance().logEvent(new Event("Entry with index " + i + " was removed (boss: "
                + entry.getBoss().getName() + ")"));
    }

    // REQUIRES: this.kills.size() < x
    // EFFECTS: Return an entry from the end, where x is the index offset fro the end
    //          (2 would be 2 indexes away from the end)
    public KillEntry getFromEnd(int x) {
        return this.kills.get(this.kills.size() - 1 - x);
    }

    // EFFECTS: Returns the total number of logged kills
    public int getTotalKills() {
        return this.kills.size();
    }

    @Override
    // EFFECTS: Serializes the BossLog in its state by the kill entries in this.kills and returns it as a JSONObject
    //          Bosses are only serialized if they have a KillEntry
    public JSONObject toJson() {
        JSONObject logAsJson = new JSONObject();

        // convert each kill, in sequence, to a JSON Array
        JSONArray killsAsArray = new JSONArray();
        for (KillEntry k : kills) {
            killsAsArray.put(k.toJson());
        }

        logAsJson.put("kills", killsAsArray);
        return logAsJson;
    }

//    // REQUIRES: name is one of the names of the bosses in the log
//    // EFFECTS: gets a boss by name
//    public Boss getBoss(String name) {
//        for (Boss b : bosses) {
//            if (b.equals(new Boss(name))) {
//                return b;
//            }
//        }
//        return null;
//    }
//

    // MODIFIES: this.bosses
    // EFFECTS: Add a new boss to the BossLog, if it doesn't already exist
    public void addNewBoss(String bossName) {
        Boss toAdd = new Boss(bossName);
        EventLog.getInstance().logEvent(new Event("Boss " + bossName + " was added to the log"));
        if (this.bosses.contains(toAdd)) {
            return;
        }
        this.bosses.add(new Boss(bossName));
    }
}
